name: Deploy to Digital Ocean with SSL

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOMAIN: "143.198.192.233.nip.io"
  EMAIL: "admin@example.com"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.DO_SSH_PRIVATE_KEY }}

      - name: Add Digital Ocean host to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.DO_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy application with SSL
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          DO_USER: ${{ secrets.DO_USER }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
          DOMAIN: ${{ env.DOMAIN }}
          EMAIL: ${{ env.EMAIL }}
        run: |
          ssh $DO_USER@$DO_HOST << EOF
            set -e

            echo "üöÄ Starting SSL deployment..."

            # Navigate to app directory
            cd /opt/fano-stt || exit 1

            # Pull latest changes
            echo "üì• Pulling latest changes..."
            git pull origin main

            # Stop existing services (all variants)
            echo "‚èπÔ∏è Stopping existing services..."
            docker-compose -f docker-compose.ssl.yml down --remove-orphans || true
            docker-compose -f docker-compose.yml down --remove-orphans || true
            docker-compose -f docker-compose.selfsigned.yml down --remove-orphans || true

            # Clean up unused resources
            echo "üßπ Cleaning up..."
            docker system prune -f

            # Create necessary directories
            echo "üìÅ Setting up directories..."
            mkdir -p ssl certbot-data nginx-logs logs
            chmod 755 ssl certbot-data nginx-logs logs

            # Update configuration with current domain and email
            echo "‚öôÔ∏è Updating SSL configuration..."
            sed -i "s/143\.198\.192\.233\.nip\.io/$DOMAIN/g" docker-compose.ssl.yml
            sed -i "s/admin@example\.com/$EMAIL/g" docker-compose.ssl.yml

            # Update nginx configuration
            sed -i "s/server_name 143\.198\.192\.233;/server_name $DOMAIN;/g" nginx.conf
            sed -i "s|ssl_certificate /etc/letsencrypt/live/143\.198\.192\.233/|ssl_certificate /etc/letsencrypt/live/$DOMAIN/|g" nginx.conf
            sed -i "s|ssl_certificate_key /etc/letsencrypt/live/143\.198\.192\.233/|ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/|g" nginx.conf

            # Check if SSL certificates already exist
            if [ -f "ssl/live/$DOMAIN/fullchain.pem" ]; then
                echo "‚úÖ SSL certificates found, starting services with SSL..."
                docker-compose -f docker-compose.ssl.yml up --build --force-recreate -d
            else
                echo "üîí Generating SSL certificates..."

                # Start nginx first for certificate generation
                docker-compose -f docker-compose.ssl.yml up --build -d nginx
                sleep 10

                # Generate SSL certificate
                docker-compose -f docker-compose.ssl.yml run --rm certbot

                if [ -f "ssl/live/$DOMAIN/fullchain.pem" ]; then
                    echo "‚úÖ SSL certificate generated successfully"

                    # Restart all services with SSL
                    docker-compose -f docker-compose.ssl.yml down
                    docker-compose -f docker-compose.ssl.yml up -d
                else
                    echo "‚ùå SSL certificate generation failed, falling back to self-signed"

                    # Generate self-signed certificate as fallback
                    mkdir -p ssl-selfsigned/live/$DOMAIN

                    # Generate private key
                    openssl genrsa -out ssl-selfsigned/live/$DOMAIN/privkey.pem 2048

                    # Generate self-signed certificate
                    openssl req -new -x509 -key ssl-selfsigned/live/$DOMAIN/privkey.pem \
                            -out ssl-selfsigned/live/$DOMAIN/fullchain.pem \
                            -days 365 -subj "/C=US/ST=Dev/L=Dev/O=FANO/CN=$DOMAIN"

                    # Copy to main ssl directory
                    cp ssl-selfsigned/live/$DOMAIN/* ssl/live/$DOMAIN/

                    # Start services with self-signed certificate
                    docker-compose -f docker-compose.ssl.yml up -d
                fi
            fi

            echo "‚è≥ Waiting for services to be ready..."
            sleep 20

            # Show service status
            echo "üìä Service status:"
            docker-compose -f docker-compose.ssl.yml ps

            # Check logs for immediate issues
            echo "üìã Recent logs:"
            docker-compose -f docker-compose.ssl.yml logs --tail=10 --no-color

            echo "üéâ SSL deployment completed!"
          EOF

      - name: Verify SSL deployment
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          DO_USER: ${{ secrets.DO_USER }}
          DOMAIN: ${{ env.DOMAIN }}
        run: |
          ssh $DO_USER@$DO_HOST << EOF
            cd /opt/fano-stt

            echo "üîç Verifying SSL deployment..."

            # Check if services are running
            if docker-compose -f docker-compose.ssl.yml ps | grep -q "Up"; then
              echo "‚úÖ SSL services are running"

              # Test HTTPS endpoint (allow self-signed for testing)
              if curl -k -f https://$DOMAIN/health >/dev/null 2>&1; then
                echo "‚úÖ HTTPS health check passed"

                # Test HTTP redirect
                HTTP_CODE=\$(curl -s -o /dev/null -w "%{http_code}" http://$DOMAIN/health || echo "000")
                if [ "\$HTTP_CODE" = "301" ]; then
                  echo "‚úÖ HTTP to HTTPS redirect working"
                else
                  echo "‚ö†Ô∏è HTTP redirect may not be working (got \$HTTP_CODE)"
                fi

                # Test certificate (basic check)
                if echo | openssl s_client -servername $DOMAIN -connect $DOMAIN:443 2>/dev/null | openssl x509 -noout -dates >/dev/null 2>&1; then
                  echo "‚úÖ SSL certificate is valid"
                else
                  echo "‚ö†Ô∏è SSL certificate check failed (may be self-signed)"
                fi

              else
                echo "‚ùå HTTPS health check failed"
                echo "Checking logs..."
                docker-compose -f docker-compose.ssl.yml logs nginx
                exit 1
              fi
            else
              echo "‚ùå SSL services are not running"
              docker-compose -f docker-compose.ssl.yml logs
              exit 1
            fi
          EOF

      - name: Setup SSL certificate renewal
        env:
          DO_HOST: ${{ secrets.DO_HOST }}
          DO_USER: ${{ secrets.DO_USER }}
        run: |
          ssh $DO_USER@$DO_HOST << 'EOF'
            cd /opt/fano-stt

            echo "üîÑ Setting up SSL certificate renewal..."

            # Create renewal script
            echo '#!/bin/bash' > renew-certificates.sh
            echo 'cd /opt/fano-stt' >> renew-certificates.sh
            echo '' >> renew-certificates.sh
            echo 'echo "$(date): Starting certificate renewal..." >> logs/ssl-renewal.log' >> renew-certificates.sh
            echo '' >> renew-certificates.sh
            echo '# Attempt renewal' >> renew-certificates.sh
            echo 'docker-compose -f docker-compose.ssl.yml run --rm certbot renew --webroot --webroot-path=/var/www/certbot --quiet' >> renew-certificates.sh
            echo '' >> renew-certificates.sh
            echo 'if [ $? -eq 0 ]; then' >> renew-certificates.sh
            echo '    # Restart nginx if renewal was successful' >> renew-certificates.sh
            echo '    docker-compose -f docker-compose.ssl.yml restart nginx' >> renew-certificates.sh
            echo '    echo "$(date): SSL certificates renewed and nginx restarted" >> logs/ssl-renewal.log' >> renew-certificates.sh
            echo 'else' >> renew-certificates.sh
            echo '    echo "$(date): SSL certificate renewal failed" >> logs/ssl-renewal.log' >> renew-certificates.sh
            echo 'fi' >> renew-certificates.sh

            chmod +x renew-certificates.sh

            # Add to crontab if not already present
            CRON_JOB="0 12,24 * * * /opt/fano-stt/renew-certificates.sh"

            if ! crontab -l 2>/dev/null | grep -q "renew-certificates.sh"; then
                (crontab -l 2>/dev/null; echo "$CRON_JOB") | crontab -
                echo "‚úÖ SSL certificate auto-renewal configured (twice daily)"
            else
                echo "‚úÖ SSL certificate auto-renewal already configured"
            fi
          EOF

      - name: Display deployment information
        if: success()
        env:
          DOMAIN: ${{ env.DOMAIN }}
        run: |
          echo "üéâ SSL deployment completed successfully!"
          echo ""
          echo "üìä Deployment Information:"
          echo "=========================="
          echo "üåê Application URL: https://$DOMAIN"
          echo "üîå WebSocket URL: wss://$DOMAIN/ws/"
          echo "üîí SSL Certificate: Let's Encrypt (or self-signed fallback)"
          echo "üîÑ Auto-renewal: Configured (twice daily)"
          echo ""
          echo "üéôÔ∏è Microphone access is now enabled!"
          echo "‚úÖ Production-ready HTTPS deployment complete!"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå SSL deployment failed!"
          echo ""
          echo "üîß Troubleshooting steps:"
          echo "1. Check if ports 80 and 443 are open"
          echo "2. Verify domain DNS configuration"
          echo "3. Check Docker and Docker Compose installation"
          echo "4. Review deployment logs above"
          echo ""
          echo "üÜò Emergency fallback:"
          echo "ssh into server and run: docker-compose -f docker-compose.yml up -d"
